import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';

export const affiliateMetricsRouter = Router();
const prisma = new PrismaClient();

/* =========================
   HELPERS DE AUTH E PARÂMETROS
   ========================= */

function base64UrlToUtf8(jsonPart: string): string {
  const s = jsonPart.replace(/-/g, '+').replace(/_/g, '/');
  const pad = s.length % 4 === 2 ? '==' : s.length % 4 === 3 ? '=' : '';
  return Buffer.from(s + pad, 'base64').toString('utf8');
}

function extractUserIdLoose(req: Request, res: Response): string | null {
  const a: any = req as any;
  const l: any = (res as any)?.locals;

  const fromKnown =
    a.user?.id ||
    a.user?.userId ||
    a.userId ||
    a.auth?.id ||
    a.auth?.userId ||
    l?.user?.id ||
    l?.user?.userId ||
    l?.auth?.id ||
    l?.auth?.userId ||
    null;

  if (fromKnown) return String(fromKnown);

  const auth = (req.get('authorization') || req.get('Authorization') || '').trim();
  const m = auth.match(/^Bearer\s+([A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+)$/);
  if (!m) return null;

  try {
    const [, token] = m;
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = JSON.parse(base64UrlToUtf8(parts[1]));
    return payload.userId || payload.sub || payload.id || null;
  } catch {
    return null;
  }
}

const ALLOWED_RANGES = new Set(['7d', '30d', '90d']);
function parseRangeDays(rangeParam: string | undefined): number {
  const v = (rangeParam || '30d').toLowerCase();
  if (!ALLOWED_RANGES.has(v)) return 30;
  return parseInt(v, 10);
}

function parseTimezone(tzParam: string | undefined): string {
  const fallback = 'America/Sao_Paulo';
  if (!tzParam) return fallback;
  const tz = tzParam.trim();
  if (/^[A-Za-z_]+\/[A-Za-z_\-]+$/.test(tz)) return tz;
  if (tz.toUpperCase() === 'UTC') return 'UTC';
  return fallback;
}

/* =========================
   DETECÇÃO DE ESQUEMA / COLUNAS
   ========================= */

async function tableExists(tableName: string): Promise<boolean> {
  const full = tableName.includes('.') ? tableName : `public.${tableName}`;
  const r = await prisma.$queryRaw<{ exists: boolean }[]>`
    SELECT to_regclass(${full}) IS NOT NULL AS "exists"
  `;
  return r?.[0]?.exists === true;
}

async function columnExists(tableName: string, columnName: string): Promise<boolean> {
  const t = tableName.includes('.') ? tableName.split('.')[1] : tableName;
  const r = await prisma.$queryRaw<{ exists: boolean }[]>`
    SELECT EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name   = ${t}
        AND column_name  = ${columnName}
    ) AS "exists"
  `;
  return r?.[0]?.exists === true;
}

type RefStrategy =
  | { kind: 'orders_affiliate_col' }   // orders.affiliate_id = $affiliateId
  | { kind: 'user_affiliates_table' }  // user_affiliates(affiliate_id,user_id)
  | { kind: 'users_referred_by_id' }   // users.referred_by_id = $affiliateId
  | { kind: 'users_referred_by_text' } // users.referred_by = $affiliateId (texto/código)
  | { kind: 'none' };

async function detectRefStrategy(): Promise<RefStrategy> {
  if (await tableExists('orders')) {
    if (await columnExists('orders', 'affiliate_id')) return { kind: 'orders_affiliate_col' };
  }
  if (await tableExists('user_affiliates')) {
    const okAff = await columnExists('user_affiliates', 'affiliate_id');
    const okUsr = await columnExists('user_affiliates', 'user_id');
    if (okAff && okUsr) return { kind: 'user_affiliates_table' };
  }
  if (await tableExists('users')) {
    if (await columnExists('users', 'referred_by_id')) return { kind: 'users_referred_by_id' };
    if (await columnExists('users', 'referred_by')) return { kind: 'users_referred_by_text' };
  }
  return { kind: 'none' };
}

async function commissionLedgerAvailable(): Promise<boolean> {
  if (!(await tableExists('commission_ledger'))) return false;
  const cols = await Promise.all([
    columnExists('commission_ledger', 'affiliate_id'),
    columnExists('commission_ledger', 'amount_usdt'),
    columnExists('commission_ledger', 'created_at'),
  ]);
  return cols.every(Boolean);
}

async function fetchReferredUserIds(affiliateId: string, strategy: RefStrategy): Promise<string[]> {
  switch (strategy.kind) {
    case 'user_affiliates_table': {
      const rows = await prisma.$queryRaw<{ user_id: string }[]>`
        SELECT ua.user_id FROM user_affiliates ua WHERE ua.affiliate_id = ${affiliateId}
      `;
      return rows.map(r => r.user_id);
    }
    case 'users_referred_by_id': {
      const rows = await prisma.$queryRaw<{ id: string }[]>`
        SELECT u.id FROM users u WHERE u.referred_by_id = ${affiliateId}
      `;
      return rows.map(r => r.id);
    }
    case 'users_referred_by_text': {
      const rows = await prisma.$queryRaw<{ id: string }[]>`
        SELECT u.id FROM users u WHERE u.referred_by = ${affiliateId}
      `;
      return rows.map(r => r.id);
    }
    default:
      return [];
  }
}

/* Orders: detectar colunas e formas de filtrar */
type OrdersShape = {
  has: boolean;
  volumeCol: 'notional_usdt' | 'volume_usdt' | null;
  pnlCol: 'realized_pnl_usdt' | 'realized_pnl' | 'pnl_usdt' | null;
  createdAtCol: 'created_at' | 'createdAt';
  affiliateCol: 'affiliate_id' | null;
  userIdCol: 'user_id' | null;
};

async function detectOrdersShape(): Promise<OrdersShape> {
  const has = await tableExists('orders');
  if (!has) {
    return { has: false, volumeCol: null, pnlCol: null, createdAtCol: 'created_at', affiliateCol: null, userIdCol: null };
  }
  const createdAtCol = (await columnExists('orders', 'created_at')) ? 'created_at' : 'createdAt';
  const affiliateCol = (await columnExists('orders', 'affiliate_id')) ? 'affiliate_id' : null;
  const userIdCol = (await columnExists('orders', 'user_id')) ? 'user_id' : null;

  const volumeCol =
    (await columnExists('orders', 'notional_usdt')) ? 'notional_usdt'
    : (await columnExists('orders', 'volume_usdt')) ? 'volume_usdt'
    : null;

  const pnlCol =
    (await columnExists('orders', 'realized_pnl_usdt')) ? 'realized_pnl_usdt'
    : (await columnExists('orders', 'realized_pnl')) ? 'realized_pnl'
    : (await columnExists('orders', 'pnl_usdt')) ? 'pnl_usdt'
    : null;

  return { has: true, volumeCol, pnlCol, createdAtCol, affiliateCol, userIdCol };
}

/* Withdrawals: detectar colunas e formas de filtrar */
type WithdrawalsShape = {
  has: boolean;
  amountCol: 'amount_usdt' | 'amount' | null;
  createdAtCol: 'created_at' | 'createdAt';
  affiliateCol: 'affiliate_id' | null;
  userIdCol: 'user_id' | null;
};

async function detectWithdrawalsShape(): Promise<WithdrawalsShape> {
  const has = await tableExists('withdrawals');
  if (!has) {
    return { has: false, amountCol: null, createdAtCol: 'created_at', affiliateCol: null, userIdCol: null };
  }
  const amountCol =
    (await columnExists('withdrawals', 'amount_usdt')) ? 'amount_usdt'
    : (await columnExists('withdrawals', 'amount')) ? 'amount'
    : null;

  const createdAtCol = (await columnExists('withdrawals', 'created_at')) ? 'created_at' : 'createdAt';
  const affiliateCol = (await columnExists('withdrawals', 'affiliate_id')) ? 'affiliate_id' : null;
  const userIdCol = (await columnExists('withdrawals', 'user_id')) ? 'user_id' : null;

  return { has: true, amountCol, createdAtCol, affiliateCol, userIdCol };
}

async function sumCommissionsPaid(affiliateId: string, days: number): Promise<number> {
  if (!(await commissionLedgerAvailable())) return 0;
  const rows = await prisma.$queryRaw<{ commission_usdt: number | null }[]>`
    SELECT COALESCE(SUM(cl.amount_usdt), 0) AS commission_usdt
    FROM commission_ledger cl
    WHERE cl.affiliate_id = ${affiliateId}
      AND cl.created_at >= now() - make_interval(days => ${days})
  `;
  return Number(rows?.[0]?.commission_usdt ?? 0);
}

/* =========================
   AGREGAÇÕES
   ========================= */

type OrdersSummary = {
  orders: number;
  volume_usdt: number;
  house_profit_orders_usdt: number;
};
type OrdersSeriesRow = { d: string; orders: number; volume_usdt: number; house_profit_orders_usdt: number; };

type WithdrawalsSummary = { withdraw_amount_total_usdt: number; withdraw_fee_house_usdt: number; };
type WithdrawalsSeriesRow = { d: string; withdraw_amount_usdt: number; withdraw_fee_house_usdt: number; };

function safeNum(n: any): number { return Number(n ?? 0) || 0; }

async function aggOrders(
  affiliateId: string,
  refStrategy: RefStrategy,
  days: number,
  tz: string
): Promise<{ summary: OrdersSummary; series: OrdersSeriesRow[]; referralsCount: number; note?: string }> {
  const shape = await detectOrdersShape();
  let note: string | undefined;

  if (!shape.has) {
    return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note: 'Tabela orders ausente.' };
  }
  if (!shape.volumeCol && !shape.pnlCol) {
    return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note: 'Colunas de volume/PnL ausentes em orders.' };
  }

  // Estratégia de filtro por afiliado
  let whereFilter = '';
  let referralsCount = 0;
  let useUserIds: string[] = [];

  if (shape.affiliateCol) {
    whereFilter = `o.${shape.affiliateCol} = $1`;
  } else if (refStrategy.kind !== 'none' && shape.userIdCol) {
    useUserIds = await fetchReferredUserIds(affiliateId, refStrategy);
    referralsCount = useUserIds.length;
    if (useUserIds.length === 0) {
      return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount, note: 'Nenhum indicado encontrado.' };
    }
    whereFilter = `o.${shape.userIdCol} = ANY($3)`;
  } else {
    note = 'Não foi possível filtrar orders por afiliado (sem affiliate_id e sem mapeamento de usuários).';
    return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note };
  }

  const vol = shape.volumeCol ? `COALESCE(o.${shape.volumeCol},0)` : `0`;
  const pnl = shape.pnlCol ? `COALESCE(o.${shape.pnlCol},0)` : `0`;

  const tzSql = tz.replace(/'/g, "''"); // tz já é validado por regex, apenas por segurança

  // Summary
  const summarySql = `
    SELECT
      COUNT(*)::int AS orders,
      SUM(${vol})::numeric AS volume_usdt,
      SUM(0.02*(${vol}) + 0.05*GREATEST(${pnl},0))::numeric AS house_profit_orders_usdt
    FROM orders o
    WHERE ${whereFilter}
      AND o.${shape.createdAtCol} >= now() - make_interval(days => $2)
  `;

  const summaryParams: any[] = [affiliateId, days];
  if (useUserIds.length) summaryParams.push(useUserIds);

  const sRows = await prisma.$queryRawUnsafe<any[]>(summarySql, ...summaryParams);
  const s = sRows?.[0] || { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 };

  // Series
  const seriesSql = `
    SELECT
      (date_trunc('day', o.${shape.createdAtCol} AT TIME ZONE '${tzSql}'))::date AS d,
      COUNT(*)::int AS orders,
      SUM(${vol})::numeric AS volume_usdt,
      SUM(0.02*(${vol}) + 0.05*GREATEST(${pnl},0))::numeric AS house_profit_orders_usdt
    FROM orders o
    WHERE ${whereFilter}
      AND o.${shape.createdAtCol} >= now() - make_interval(days => $2)
    GROUP BY 1
    ORDER BY 1
  `;
  const serRows = await prisma.$queryRawUnsafe<any[]>(seriesSql, ...summaryParams);

  const summary: OrdersSummary = {
    orders: safeNum(s.orders),
    volume_usdt: safeNum(s.volume_usdt),
    house_profit_orders_usdt: safeNum(s.house_profit_orders_usdt),
  };
  const series: OrdersSeriesRow[] = (serRows || []).map(r => ({
    d: String(r.d),
    orders: safeNum(r.orders),
    volume_usdt: safeNum(r.volume_usdt),
    house_profit_orders_usdt: safeNum(r.house_profit_orders_usdt),
  }));

  return { summary, series, referralsCount, note };
}

async function aggWithdrawals(
  affiliateId: string,
  refStrategy: RefStrategy,
  days: number,
  tz: string
): Promise<{ summary: WithdrawalsSummary; series: WithdrawalsSeriesRow[]; used: boolean; note?: string }> {
  const shape = await detectWithdrawalsShape();
  if (!shape.has || !shape.amountCol) {
    return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'Tabela withdrawals ausente ou sem coluna amount.' };
  }

  // Filtro: por affiliate_id direto OU via user_id com lista de indicados
  let whereFilter = '';
  let params: any[] = [affiliateId, days];
  let used = true;

  if (shape.affiliateCol) {
    whereFilter = `w.${shape.affiliateCol} = $1`;
  } else if (shape.userIdCol) {
    const strategy = refStrategy.kind === 'orders_affiliate_col' ? await detectRefStrategy() : refStrategy;
    const userIds = await fetchReferredUserIds(affiliateId, strategy);
    if (!userIds.length) {
      return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'Sem indicados para mapear saques.' };
    }
    whereFilter = `w.${shape.userIdCol} = ANY($3)`;
    params = [affiliateId, days, userIds];
  } else {
    return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'withdrawals sem affiliate_id e sem user_id.' };
  }

  const amt = `COALESCE(w.${shape.amountCol},0)`;
  const tzSql = tz.replace(/'/g, "''");

  const sumSql = `
    SELECT
      SUM(${amt})::numeric AS withdraw_amount_total_usdt,
      SUM(0.02*(${amt}))::numeric AS withdraw_fee_house_usdt
    FROM withdrawals w
    WHERE ${whereFilter}
      AND w.${shape.createdAtCol} >= now() - make_interval(days => $2)
  `;
  const sumRows = await prisma.$queryRawUnsafe<any[]>(sumSql, ...params);
  const s = sumRows?.[0] || { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 };

  const seriesSql = `
    SELECT
      (date_trunc('day', w.${shape.createdAtCol} AT TIME ZONE '${tzSql}'))::date AS d,
      SUM(${amt})::numeric AS withdraw_amount_usdt,
      SUM(0.02*(${amt}))::numeric AS withdraw_fee_house_usdt
    FROM withdrawals w
    WHERE ${whereFilter}
      AND w.${shape.createdAtCol} >= now() - make_interval(days => $2)
    GROUP BY 1
    ORDER BY 1
  `;
  const serRows = await prisma.$queryRawUnsafe<any[]>(seriesSql, ...params);

  return {
    summary: {
      withdraw_amount_total_usdt: safeNum(s.withdraw_amount_total_usdt),
      withdraw_fee_house_usdt: safeNum(s.withdraw_fee_house_usdt),
    },
    series: (serRows || []).map(r => ({
      d: String(r.d),
      withdraw_amount_usdt: safeNum(r.withdraw_amount_usdt),
      withdraw_fee_house_usdt: safeNum(r.withdraw_fee_house_usdt),
    })),
    used: true
  };
}

/* =========================
   ROTA (RESUMO + SÉRIE)
   ========================= */

affiliateMetricsRouter.get('/metrics/summary', async (req: Request, res: Response) => {
  try {
    const userId = extractUserIdLoose(req, res);
    if (!userId) return res.status(401).json({ error: 'Unauthorized' });

    const days = parseRangeDays(String(req.query.range));
    const tz = parseTimezone(String(req.query.tz));

    const strategy = await detectRefStrategy();

    // ORDERS
    const { summary: ordS, series: ordSer, referralsCount, note: ordersNote } =
      await aggOrders(userId, strategy, days, tz);

    // WITHDRAWALS (2% house)
    const { summary: wdrS, series: wdrSer, used: usedWithdrawals, note: wdrNote } =
      await aggWithdrawals(userId, strategy, days, tz);

    // Consolidação
    const house_profit_total_usdt = safeNum(ordS.house_profit_orders_usdt) + safeNum(wdrS.withdraw_fee_house_usdt);
    const affiliate_commission_due_usdt = 0.05 * house_profit_total_usdt;

    // Merge de séries por dia
    const byDay: Record<string, any> = {};
    for (const r of ordSer) {
      byDay[r.d] = {
        date: r.d,
        orders: r.orders,
        volume_usdt: r.volume_usdt,
        house_profit_orders_usdt: r.house_profit_orders_usdt,
        withdraw_amount_usdt: 0,
        withdraw_fee_house_usdt: 0,
      };
    }
    for (const r of wdrSer) {
      if (!byDay[r.d]) {
        byDay[r.d] = {
          date: r.d, orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0,
          withdraw_amount_usdt: r.withdraw_amount_usdt,
          withdraw_fee_house_usdt: r.withdraw_fee_house_usdt,
        };
      } else {
        byDay[r.d].withdraw_amount_usdt = r.withdraw_amount_usdt;
        byDay[r.d].withdraw_fee_house_usdt = r.withdraw_fee_house_usdt;
      }
    }
    const series = Object.values(byDay)
      .sort((a: any, b: any) => String(a.date).localeCompare(String(b.date)))
      .map((r: any) => ({
        date: String(r.date),
        orders: r.orders,
        volume_usdt: r.volume_usdt,
        house_profit_orders_usdt: r.house_profit_orders_usdt,
        withdraw_amount_usdt: r.withdraw_amount_usdt,
        withdraw_fee_house_usdt: r.withdraw_fee_house_usdt,
        house_profit_total_usdt: r.house_profit_orders_usdt + r.withdraw_fee_house_usdt,
        affiliate_commission_usdt: 0.05 * (r.house_profit_orders_usdt + r.withdraw_fee_house_usdt),
      }));

    const note = [ordersNote, usedWithdrawals ? undefined : wdrNote].filter(Boolean).join(' | ') || undefined;

    return res.json({
      version: 'v2',
      range: `${days}d`,
      timezone: tz,
      summary: {
        referrals: referralsCount,
        orders: ordS.orders || 0,
        volume_usdt: ordS.volume_usdt || 0,
        // compat: campo antigo agora retorna o TOTAL
        house_profit_usdt: house_profit_total_usdt,
        // novos campos detalhados
        house_profit_orders_usdt: ordS.house_profit_orders_usdt || 0,
        withdraw_amount_total_usdt: wdrS.withdraw_amount_total_usdt || 0,
        withdraw_fee_house_usdt: wdrS.withdraw_fee_house_usdt || 0,
        house_profit_total_usdt,
        affiliate_commission_due_usdt,
        commissions_paid_usdt: await sumCommissionsPaid(userId, days),
      },
      series,
      note,
    });
  } catch (e) {
    return res.status(500).json({ error: 'Internal Server Error', code: 'AFFILIATE_METRICS_SUMMARY_FAILED' });
  }
});
