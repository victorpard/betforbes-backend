import { Router, Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

/** Regras:
 * - Depósito: 0% casa
 * - Saque: 2% casa
 * - Criação de ordem: 2% do notional (valor da ordem)
 * - Fechamento: 5% do LUCRO (>0) da ordem
 * - Pai do afiliado: 5% do LUCRO DA CASA gerado por afiliados (apenas se > 0)
 */
const FEE_ORDER_CREATE = 0.02;
const FEE_ORDER_PROFIT = 0.05; // TODO: requer origem de PnL
const FEE_WITHDRAW = 0.02;
const AFF_PARENT_CUT = 0.05;

export const affiliateMetricsRouter = Router();

type Range = "30d" | "90d" | "365d";
function windowFor(range: Range, now = new Date()) {
  const end = now;
  const start = new Date(end);
  if (range === "30d") start.setDate(start.getDate() - 30);
  else if (range === "90d") start.setDate(start.getDate() - 90);
  else start.setDate(start.getDate() - 365);
  return { start, end };
}

function n(x: any): number { const v = Number(x); return Number.isFinite(v) ? v : 0; }
function r2(x: number) { return Math.round((x + Number.EPSILON) * 100) / 100; }

/**
 * GET /api/affiliate/metrics/summary
 * (O ops.route.ts injeta este handler para servir /api/ops/metrics/summary também.)
 */
affiliateMetricsRouter.get("/metrics/summary", async (req: Request, res: Response) => {
  const prisma = (req as any).prisma as PrismaClient;
if (!prisma) return res.status(500).json({ error: 'prisma_not_injected' });

  const range = (String(req.query.range || "30d") as Range);
  const tz = String(req.query.tz || "America/Sao_Paulo");
  const affiliateId = String(req.query.affiliateId || "all");
  const { start, end } = windowFor(range);

  // Users: usa referredBy (existe no seu modelo), não referredById
  const users = await prisma.user.findMany({
    where: { createdAt: { gte: start, lt: end } },
    select: { id: true, referredBy: true }, // ✅ compatível
  });

  // Orders: usa amount (Decimal) — não há notionalUSDT/pnl*
  const orders = await (prisma as any).order.findMany({
    where: { createdAt: { gte: start, lt: end } },
    select: { id: true, userId: true, createdAt: true, amount: true, status: true, description: true }, // ✅ compatível
  });

  // Withdrawals: tenta tabela withdrawals com amount; se não existir, considera []
  const withdrawals = await (prisma as any).withdrawal?.findMany?.({
    where: { createdAt: { gte: start, lt: end } },
    select: { amount: true, createdAt: true },
  }).catch(() => []) as any[];

  // Pagamentos de comissão (opcional; se não existir, 0)
  const commissionPayments = await (prisma as any).affiliateCommissionPayment?.findMany?.({
    where: { createdAt: { gte: start, lt: end } },
    select: { amount: true },
  }).catch(() => []) as any[];

  // ===== Cálculos =====
  const referrals = users.filter(u => !!u.referredBy).length;

  let volume = 0;
  let feeCreate = 0;
  let feeClose = 0; // TODO: só entra quando tivermos PnL (>0)

  const houseFromAffiliateChild: Record<string, number> = {};

  for (const o of orders) {
    const amt = n(o.amount);
    volume += amt;

    const fCreate = amt * FEE_ORDER_CREATE;
    const fClose = 0; // TODO: integrar PnL assim que houver origem (ex.: settlements/trades)
    feeCreate += fCreate;
    feeClose += fClose;

    const houseThis = fCreate + fClose;

    // Marca base do "pai": se o usuário tem referredBy (!= null), conta como afiliado
    const u = users.find(u => u.id === o.userId);
    if (u?.referredBy) {
      houseFromAffiliateChild[o.userId] = (houseFromAffiliateChild[o.userId] ?? 0) + houseThis;
    }
  }

  const house_profit_orders_usdt = feeCreate + feeClose; // nunca negativo pelas regras

  // Saques: 2% do total
  let withdraw_amount_total_usdt = 0;
  for (const w of withdrawals) withdraw_amount_total_usdt += n(w.amount);
  const withdraw_fee_house_usdt = withdraw_amount_total_usdt * FEE_WITHDRAW;

  const house_profit_total_usdt = house_profit_orders_usdt + withdraw_fee_house_usdt;

  // Comissão do pai: 5% do lucro da casa gerado pelos afiliados (apenas se > 0)
  let affiliate_commission_due_usdt = 0;
  for (const k of Object.keys(houseFromAffiliateChild)) {
    const base = houseFromAffiliateChild[k];
    if (base > 0) affiliate_commission_due_usdt += base * AFF_PARENT_CUT;
  }

  const commissions_paid_usdt = (commissionPayments || []).reduce(
    (acc: number, p: any) => acc + n(p.amount),
    0
  );

  return res.json({
    version: "v2",
    range,
    timezone: tz,
    scope: affiliateId === "all" ? "global" : "affiliate",
    summary: {
      referrals,
      orders: orders.length,
      volume_usdt: r2(volume),
      house_profit_usdt: r2(house_profit_orders_usdt), // alias
      house_profit_orders_usdt: r2(house_profit_orders_usdt),
      withdraw_amount_total_usdt: r2(withdraw_amount_total_usdt),
      withdraw_fee_house_usdt: r2(withdraw_fee_house_usdt),
      house_profit_total_usdt: r2(house_profit_total_usdt),
      affiliate_commission_due_usdt: r2(affiliate_commission_due_usdt),
      commissions_paid_usdt: r2(commissions_paid_usdt),
    },
  });
});
