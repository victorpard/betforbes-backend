import { Router, Request, Response } from 'express';
import { PrismaClient } from '@prisma/client';

export const affiliateMetricsRouter = Router();
const prisma = new PrismaClient();

/* =========================
   HELPERS DE AUTH E PARÂMETROS
   ========================= */

function base64UrlToUtf8(jsonPart: string): string {
  const s = jsonPart.replace(/-/g, '+').replace(/_/g, '/');
  const pad = s.length % 4 === 2 ? '==' : s.length % 4 === 3 ? '=' : '';
  return Buffer.from(s + pad, 'base64').toString('utf8');
}

function extractUserIdLoose(req: Request, res: Response): string | null {
  const a: any = req as any;
  const l: any = (res as any)?.locals;

  const fromKnown =
    a.user?.id ||
    a.user?.userId ||
    a.userId ||
    a.auth?.id ||
    a.auth?.userId ||
    l?.user?.id ||
    l?.user?.userId ||
    l?.auth?.id ||
    l?.auth?.userId ||
    null;

  if (fromKnown) return String(fromKnown);

  const auth = (req.get('authorization') || req.get('Authorization') || '').trim();
  const m = auth.match(/^Bearer\s+([A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+)$/);
  if (!m) return null;

  try {
    const [, token] = m;
    const parts = token.split('.');
    if (parts.length !== 3) return null;
    const payload = JSON.parse(base64UrlToUtf8(parts[1]));
    return payload.userId || payload.sub || payload.id || null;
  } catch {
    return null;
  }
}

const ALLOWED_RANGES = new Set(['7d', '30d', '90d']);
function parseRangeDays(rangeParam: string | undefined): number {
  const v = (rangeParam || '30d').toLowerCase();
  if (!ALLOWED_RANGES.has(v)) return 30;
  return parseInt(v, 10);
}

function parseTimezone(tzParam: string | undefined): string {
  const fallback = 'America/Sao_Paulo';
  if (!tzParam) return fallback;
  const tz = tzParam.trim();
  if (/^[A-Za-z_]+\/[A-Za-z_\-]+$/.test(tz)) return tz;
  if (tz.toUpperCase() === 'UTC') return 'UTC';
  return fallback;
}

/* =========================
   DETECÇÃO DE ESQUEMA / COLUNAS
   ========================= */

async function tableExists(tableName: string): Promise<boolean> {
  const full = tableName.includes('.') ? tableName : `public.${tableName}`;
  const r = await prisma.$queryRaw<{ exists: boolean }[]>`
    SELECT to_regclass(${full}) IS NOT NULL AS "exists"
  `;
  return r?.[0]?.exists === true;
}

async function columnExists(tableName: string, columnName: string): Promise<boolean> {
  const t = tableName.includes('.') ? tableName.split('.')[1] : tableName;
  const r = await prisma.$queryRaw<{ exists: boolean }[]>`
    SELECT EXISTS (
      SELECT 1
      FROM information_schema.columns
      WHERE table_schema = 'public'
        AND table_name   = ${t}
        AND column_name  = ${columnName}
    ) AS "exists"
  `;
  return r?.[0]?.exists === true;
}

type RefStrategy =
  | { kind: 'orders_affiliate_col' }   // orders.(affiliate_id|affiliateId) = $affiliateId
  | { kind: 'user_affiliates_table' }  // user_affiliates(affiliate_id,user_id)
  | { kind: 'users_referred' }         // users.(referred_by_id|referredById|referred_by|referredBy) = $affiliateId
  | { kind: 'none' };

async function detectRefStrategy(): Promise<RefStrategy> {
  if (await tableExists('orders')) {
    if (await columnExists('orders', 'affiliate_id')) return { kind: 'orders_affiliate_col' };
    if (await columnExists('orders', 'affiliateId')) return { kind: 'orders_affiliate_col' };
  }
  if (await tableExists('user_affiliates')) {
    const okAff = (await columnExists('user_affiliates', 'affiliate_id')) || (await columnExists('user_affiliates', 'affiliateId'));
    const okUsr = (await columnExists('user_affiliates', 'user_id')) || (await columnExists('user_affiliates', 'userId'));
    if (okAff && okUsr) return { kind: 'user_affiliates_table' };
  }
  if (await tableExists('users')) {
    if (
      (await columnExists('users', 'referred_by_id')) ||
      (await columnExists('users', 'referredById')) ||
      (await columnExists('users', 'referred_by')) ||
      (await columnExists('users', 'referredBy'))
    ) return { kind: 'users_referred' };
  }
  return { kind: 'none' };
}

async function commissionLedgerAvailable(): Promise<boolean> {
  if (!(await tableExists('commission_ledger'))) return false;
  const cols = await Promise.all([
    columnExists('commission_ledger', 'affiliate_id'),
    columnExists('commission_ledger', 'amount_usdt'),
    columnExists('commission_ledger', 'created_at'),
  ]);
  return cols.every(Boolean);
}

/* =========================
   UTIL: ID's de indicados
   ========================= */

async function fetchReferredUserIds(affiliateId: string, strategy: RefStrategy): Promise<string[]> {
  if (strategy.kind === 'user_affiliates_table') {
    const affCol = (await columnExists('user_affiliates', 'affiliate_id')) ? 'affiliate_id' : 'affiliateId';
    const usrCol = (await columnExists('user_affiliates', 'user_id')) ? 'user_id' : 'userId';
    const rows = await prisma.$queryRaw<{ user_id: string }[]>`
      SELECT ua.${prisma.raw(usrCol)} AS user_id
      FROM user_affiliates ua
      WHERE ua.${prisma.raw(affCol)} = ${affiliateId}
    `;
    return rows.map(r => r.user_id);
  }

  if (strategy.kind === 'users_referred') {
    const col =
      (await columnExists('users', 'referred_by_id')) ? 'referred_by_id' :
      (await columnExists('users', 'referredById'))   ? 'referredById'   :
      (await columnExists('users', 'referred_by'))    ? 'referred_by'    :
      (await columnExists('users', 'referredBy'))     ? 'referredBy'     :
      null;

    if (!col) return [];
    const rows = await prisma.$queryRaw<{ id: string }[]>`
      SELECT u.id FROM users u WHERE u.${prisma.raw(col)} = ${affiliateId}
    `;
    return rows.map(r => r.id);
  }

  return [];
}

async function sumCommissionsPaid(affiliateId: string, days: number): Promise<number> {
  if (!(await commissionLedgerAvailable())) return 0;
  const rows = await prisma.$queryRaw<{ commission_usdt: number | null }[]>`
    SELECT COALESCE(SUM(cl.amount_usdt), 0) AS commission_usdt
    FROM commission_ledger cl
    WHERE cl.affiliate_id = ${affiliateId}
      AND cl.created_at >= now() - make_interval(days => ${days})
  `;
  return Number(rows?.[0]?.commission_usdt ?? 0);
}

/* =========================
   SHAPES (orders/withdrawals)
   ========================= */

type OrdersShape = {
  has: boolean;
  volumeCol: string | null;     // notional_usdt | volume_usdt | notional | ...
  pnlCol: string | null;        // realized_pnl_usdt | realized_pnl | pnl_usdt | ...
  createdAtCol: string;         // created_at | createdAt
  affiliateCol: string | null;  // affiliate_id | affiliateId
  userIdCol: string | null;     // user_id | userId
};

async function detectOrdersShape(): Promise<OrdersShape> {
  const has = await tableExists('orders');
  if (!has) {
    return { has: false, volumeCol: null, pnlCol: null, createdAtCol: 'created_at', affiliateCol: null, userIdCol: null };
  }
  const candidatesVol = ['notional_usdt','volume_usdt','notional','notionalUSD','volume','volumeUSD'];
  const candidatesPnl = ['realized_pnl_usdt','realized_pnl','pnl_usdt','pnlUSD','pnl'];
  let volumeCol: string | null = null, pnlCol: string | null = null;

  for (const c of candidatesVol) if (await columnExists('orders', c)) { volumeCol = c; break; }
  for (const c of candidatesPnl) if (await columnExists('orders', c)) { pnlCol = c; break; }

  const createdAtCol = (await columnExists('orders', 'created_at')) ? 'created_at' : 'createdAt';
  const affiliateCol = (await columnExists('orders', 'affiliate_id')) ? 'affiliate_id' : (await columnExists('orders', 'affiliateId')) ? 'affiliateId' : null;
  const userIdCol    = (await columnExists('orders', 'user_id'))     ? 'user_id'     : (await columnExists('orders', 'userId'))     ? 'userId'     : null;

  return { has: true, volumeCol, pnlCol, createdAtCol, affiliateCol, userIdCol };
}

type WithdrawalsShape = {
  has: boolean;
  amountCol: string | null;     // amount_usdt | amount | value | value_usdt
  createdAtCol: string;         // created_at | createdAt
  affiliateCol: string | null;  // affiliate_id | affiliateId
  userIdCol: string | null;     // user_id | userId
};

async function detectWithdrawalsShape(): Promise<WithdrawalsShape> {
  const has = await tableExists('withdrawals');
  if (!has) {
    return { has: false, amountCol: null, createdAtCol: 'created_at', affiliateCol: null, userIdCol: null };
  }
  const candidatesAmt = ['amount_usdt','amount','value_usdt','value'];
  let amountCol: string | null = null;
  for (const c of candidatesAmt) if (await columnExists('withdrawals', c)) { amountCol = c; break; }

  const createdAtCol = (await columnExists('withdrawals', 'created_at')) ? 'created_at' : 'createdAt';
  const affiliateCol = (await columnExists('withdrawals', 'affiliate_id')) ? 'affiliate_id' : (await columnExists('withdrawals', 'affiliateId')) ? 'affiliateId' : null;
  const userIdCol    = (await columnExists('withdrawals', 'user_id'))     ? 'user_id'     : (await columnExists('withdrawals', 'userId'))     ? 'userId'     : null;

  return { has: true, amountCol, createdAtCol, affiliateCol, userIdCol };
}

function safeNum(n: any): number { return Number(n ?? 0) || 0; }

/* =========================
   AGREGAÇÕES
   ========================= */

type OrdersSummary = { orders: number; volume_usdt: number; house_profit_orders_usdt: number; };
type OrdersSeriesRow = { d: string; orders: number; volume_usdt: number; house_profit_orders_usdt: number; };

async function aggOrders(
  affiliateId: string,
  refStrategy: RefStrategy,
  days: number,
  tz: string
): Promise<{ summary: OrdersSummary; series: OrdersSeriesRow[]; referralsCount: number; note?: string }> {
  const shape = await detectOrdersShape();
  let note: string | undefined;

  if (!shape.has) return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note: 'Tabela orders ausente.' };
  if (!shape.volumeCol && !shape.pnlCol) return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note: 'orders sem colunas de volume/PnL.' };

  // filtro por afiliado
  let whereFilter = '';
  let referralsCount = 0;
  let useUserIds: string[] = [];

  if (shape.affiliateCol) {
    whereFilter = `o.${shape.affiliateCol} = $1`;
  } else if (refStrategy.kind !== 'none' && shape.userIdCol) {
    useUserIds = await fetchReferredUserIds(affiliateId, refStrategy);
    referralsCount = useUserIds.length;
    if (useUserIds.length === 0) {
      return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount, note: 'Nenhum indicado encontrado.' };
    }
    whereFilter = `o.${shape.userIdCol} = ANY($3)`;
  } else {
    note = 'Não foi possível filtrar orders por afiliado (sem affiliate_id e sem mapeamento de usuários).';
    return { summary: { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 }, series: [], referralsCount: 0, note };
  }

  const vol = shape.volumeCol ? `COALESCE(o.${shape.volumeCol},0)` : `0`;
  const pnl = shape.pnlCol ? `COALESCE(o.${shape.pnlCol},0)` : `0`;
  const tzSql = tz.replace(/'/g, "''");

  const summarySql = `
    SELECT
      COUNT(*)::int AS orders,
      SUM(${vol})::numeric AS volume_usdt,
      SUM(0.02*(${vol}) + 0.05*GREATEST(${pnl},0))::numeric AS house_profit_orders_usdt
    FROM orders o
    WHERE ${whereFilter}
      AND o.${shape.createdAtCol} >= now() - make_interval(days => $2)
  `;
  const summaryParams: any[] = [affiliateId, days];
  if (useUserIds.length) summaryParams.push(useUserIds);
  const sRows = await prisma.$queryRawUnsafe<any[]>(summarySql, ...summaryParams);
  const s = sRows?.[0] || { orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0 };

  const seriesSql = `
    SELECT
      (date_trunc('day', o.${shape.createdAtCol} AT TIME ZONE '${tzSql}'))::date AS d,
      COUNT(*)::int AS orders,
      SUM(${vol})::numeric AS volume_usdt,
      SUM(0.02*(${vol}) + 0.05*GREATEST(${pnl},0))::numeric AS house_profit_orders_usdt
    FROM orders o
    WHERE ${whereFilter}
      AND o.${shape.createdAtCol} >= now() - make_interval(days => $2)
    GROUP BY 1
    ORDER BY 1
  `;
  const serRows = await prisma.$queryRawUnsafe<any[]>(seriesSql, ...summaryParams);

  return {
    summary: {
      orders: safeNum(s.orders),
      volume_usdt: safeNum(s.volume_usdt),
      house_profit_orders_usdt: safeNum(s.house_profit_orders_usdt),
    },
    series: (serRows || []).map(r => ({
      d: String(r.d),
      orders: safeNum(r.orders),
      volume_usdt: safeNum(r.volume_usdt),
      house_profit_orders_usdt: safeNum(r.house_profit_orders_usdt),
    })),
    referralsCount,
    note
  };
}

type WithdrawalsSummary = { withdraw_amount_total_usdt: number; withdraw_fee_house_usdt: number; };
type WithdrawalsSeriesRow = { d: string; withdraw_amount_usdt: number; withdraw_fee_house_usdt: number; };

async function aggWithdrawals(
  affiliateId: string,
  refStrategy: RefStrategy,
  days: number,
  tz: string
): Promise<{ summary: WithdrawalsSummary; series: WithdrawalsSeriesRow[]; used: boolean; note?: string }> {
  const shape = await detectWithdrawalsShape();
  if (!shape.has || !shape.amountCol) {
    return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'Tabela withdrawals ausente ou sem coluna amount.' };
  }

  let whereFilter = '';
  let params: any[] = [affiliateId, days];
  let used = true;

  if (shape.affiliateCol) {
    whereFilter = `w.${shape.affiliateCol} = $1`;
  } else if (shape.userIdCol) {
    const userIds = await fetchReferredUserIds(affiliateId, refStrategy);
    if (!userIds.length) {
      return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'Sem indicados para mapear saques.' };
    }
    whereFilter = `w.${shape.userIdCol} = ANY($3)`;
    params = [affiliateId, days, userIds];
  } else {
    return { summary: { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 }, series: [], used: false, note: 'withdrawals sem affiliate_id e sem user_id.' };
  }

  const amt = `COALESCE(w.${shape.amountCol},0)`;
  const tzSql = tz.replace(/'/g, "''");

  const sumSql = `
    SELECT
      SUM(${amt})::numeric AS withdraw_amount_total_usdt,
      SUM(0.02*(${amt}))::numeric AS withdraw_fee_house_usdt
    FROM withdrawals w
    WHERE ${whereFilter}
      AND w.${shape.createdAtCol} >= now() - make_interval(days => $2)
  `;
  const sumRows = await prisma.$queryRawUnsafe<any[]>(sumSql, ...params);
  const s = sumRows?.[0] || { withdraw_amount_total_usdt: 0, withdraw_fee_house_usdt: 0 };

  const seriesSql = `
    SELECT
      (date_trunc('day', w.${shape.createdAtCol} AT TIME ZONE '${tzSql}'))::date AS d,
      SUM(${amt})::numeric AS withdraw_amount_usdt,
      SUM(0.02*(${amt}))::numeric AS withdraw_fee_house_usdt
    FROM withdrawals w
    WHERE ${whereFilter}
      AND w.${shape.createdAtCol} >= now() - make_interval(days => $2)
    GROUP BY 1
    ORDER BY 1
  `;
  const serRows = await prisma.$queryRawUnsafe<any[]>(seriesSql, ...params);

  return {
    summary: {
      withdraw_amount_total_usdt: safeNum(s.withdraw_amount_total_usdt),
      withdraw_fee_house_usdt: safeNum(s.withdraw_fee_house_usdt),
    },
    series: (serRows || []).map(r => ({
      d: String(r.d),
      withdraw_amount_usdt: safeNum(r.withdraw_amount_usdt),
      withdraw_fee_house_usdt: safeNum(r.withdraw_fee_house_usdt),
    })),
    used
  };
}

/* =========================
   ROTA (RESUMO + SÉRIE)
   ========================= */

affiliateMetricsRouter.get('/metrics/summary', async (req: Request, res: Response) => {
  try {
    const userId = extractUserIdLoose(req, res);
    if (!userId) return res.status(401).json({ error: 'Unauthorized' });

    const days = parseRangeDays(String(req.query.range));
    const tz = parseTimezone(String(req.query.tz));

    const strategy = await detectRefStrategy();

    // ORDERS
    const { summary: ordS, series: ordSer, referralsCount, note: ordersNote } =
      await aggOrders(userId, strategy, days, tz);

    // WITHDRAWALS (2% house)
    const { summary: wdrS, series: wdrSer, used: usedWithdrawals, note: wdrNote } =
      await aggWithdrawals(userId, strategy, days, tz);

    // Consolidação
    const house_profit_total_usdt = safeNum(ordS.house_profit_orders_usdt) + safeNum(wdrS.withdraw_fee_house_usdt);
    const affiliate_commission_due_usdt = 0.05 * house_profit_total_usdt;

    // Merge de séries
    const byDay: Record<string, any> = {};
    for (const r of ordSer) {
      byDay[r.d] = {
        date: r.d,
        orders: r.orders,
        volume_usdt: r.volume_usdt,
        house_profit_orders_usdt: r.house_profit_orders_usdt,
        withdraw_amount_usdt: 0,
        withdraw_fee_house_usdt: 0,
      };
    }
    for (const r of wdrSer) {
      if (!byDay[r.d]) {
        byDay[r.d] = {
          date: r.d, orders: 0, volume_usdt: 0, house_profit_orders_usdt: 0,
          withdraw_amount_usdt: r.withdraw_amount_usdt,
          withdraw_fee_house_usdt: r.withdraw_fee_house_usdt,
        };
      } else {
        byDay[r.d].withdraw_amount_usdt = r.withdraw_amount_usdt;
        byDay[r.d].withdraw_fee_house_usdt = r.withdraw_fee_house_usdt;
      }
    }
    const series = Object.values(byDay)
      .sort((a: any, b: any) => String(a.date).localeCompare(String(b.date)))
      .map((r: any) => ({
        date: String(r.date),
        orders: r.orders,
        volume_usdt: r.volume_usdt,
        house_profit_orders_usdt: r.house_profit_orders_usdt,
        withdraw_amount_usdt: r.withdraw_amount_usdt,
        withdraw_fee_house_usdt: r.withdraw_fee_house_usdt,
        house_profit_total_usdt: r.house_profit_orders_usdt + r.withdraw_fee_house_usdt,
        affiliate_commission_usdt: 0.05 * (r.house_profit_orders_usdt + r.withdraw_fee_house_usdt),
      }));

    const note = [ordersNote, usedWithdrawals ? undefined : wdrNote].filter(Boolean).join(' | ') || undefined;

    return res.json({
      version: 'v2',
      range: `${days}d`,
      timezone: tz,
      summary: {
        referrals: referralsCount,
        orders: ordS.orders || 0,
        volume_usdt: ordS.volume_usdt || 0,
        house_profit_usdt: house_profit_total_usdt,         // compat (total)
        house_profit_orders_usdt: ordS.house_profit_orders_usdt || 0,
        withdraw_amount_total_usdt: wdrS.withdraw_amount_total_usdt || 0,
        withdraw_fee_house_usdt: wdrS.withdraw_fee_house_usdt || 0,
        house_profit_total_usdt,
        affiliate_commission_due_usdt,
        commissions_paid_usdt: await sumCommissionsPaid(userId, days),
      },
      series,
      note,
    });
  } catch {
    return res.status(500).json({ error: 'Internal Server Error', code: 'AFFILIATE_METRICS_SUMMARY_FAILED' });
  }
});
