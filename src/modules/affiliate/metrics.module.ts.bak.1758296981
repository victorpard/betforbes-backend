import { Router, Request, Response } from "express";
import { PrismaClient } from "@prisma/client";

export const affiliateMetricsRouter = Router();

type Range = "30d" | "90d" | "365d" | "all";

function windowFor(range: Range, now = new Date()) {
  const end = now;
  const start = new Date(end);
  if (range === "all") { start.setTime(0); return { start, end }; }
  if (range === "30d") start.setDate(start.getDate() - 30);
  else if (range === "90d") start.setDate(start.getDate() - 90);
  else start.setDate(start.getDate() - 365);
  return { start, end };
}

// Normaliza entrada
function pickRange(q: any): Range {
  const r = String(q?.range || "30d").toLowerCase();
  return (["30d","90d","365d","all"] as Range[]).includes(r as Range) ? (r as Range) : "30d";
}
function pickTZ(q: any): string {
  return String(q?.tz || "America/Sao_Paulo");
}
function pickAffiliate(q: any): { mode: "all" | "byId", id?: string } {
  const raw = q?.affiliateId;
  if (!raw || String(raw).toLowerCase() === "all") return { mode: "all" };
  return { mode: "byId", id: String(raw) };
}

// Handler: GET /api/affiliate/metrics/summary
affiliateMetricsRouter.get("/metrics/summary", async (req: Request, res: Response) => {
  // prisma injetado pelo OPS? se não, cria singleton “de segurança”
  let prisma: PrismaClient;
  try {
    prisma = (req as any).prisma as PrismaClient;
    if (!prisma) {
      const g: any = global as any;
      if (!g.__ops_prisma) g.__ops_prisma = new PrismaClient();
      prisma = g.__ops_prisma as PrismaClient;
    }
  } catch {
    const g: any = global as any;
    if (!g.__ops_prisma) g.__ops_prisma = new PrismaClient();
    prisma = g.__ops_prisma as PrismaClient;
  }

  try {
    const range = pickRange(req.query);
    const tz = pickTZ(req.query);
    const aff = pickAffiliate(req.query);

    const { start, end } = windowFor(range);
    // Datas em ISO para $queryRaw
    const startISO = start.toISOString();
    const endISO = end.toISOString();

    // Monta WHERE/JOINS dinamicamente
    // - GLOBAL (all): não filtra por afiliado
    // - byId: filtra usuários com referredById = :affId
    const isGlobal = aff.mode === "all";

    const ordersJoin = isGlobal
      ? `/* global */`
      : `JOIN public.users u_o ON u_o.id = o."userId" AND u_o."referredById" = $3`;
    const ordersWhere = `o."createdAt" >= $1 AND o."createdAt" <= $2`;

    const withdrawsJoin = isGlobal
      ? `/* global */`
      : `JOIN public.users u_w ON u_w.id = w."userId" AND u_w."referredById" = $3`;
    const withdrawsWhere = `w."createdAt" >= $1 AND w."createdAt" <= $2`;

    // Query única com CTEs (igual ao que você testou, só que com WHERE dinâmico)
    const sql = `
      with orders as (
        select
          count(*) as orders,
          coalesce(sum(o.amount),0)::numeric               as volume_usdt,
          coalesce(sum(0.02*o.amount
                       + 0.05*greatest(o.realized_pnl_usdt,0)),0)::numeric as house_profit_orders_usdt
        from public.orders o
        ${ordersJoin}
        where ${ordersWhere}
      ),
      withdraws as (
        select
          coalesce(sum(w.amount_usdt),0)::numeric    as withdraw_amount_total_usdt,
          coalesce(sum(w.fee_house_usdt),0)::numeric as withdraw_fee_house_usdt
        from public.withdrawals w
        ${withdrawsJoin}
        where ${withdrawsWhere}
      )
      select
        (select count(*) from public.users) as users_total,
        (select count(*) from public.users where "referredById" is not null) as referrals_total,
        o.orders,
        o.volume_usdt,
        o.house_profit_orders_usdt,
        w.withdraw_amount_total_usdt,
        w.withdraw_fee_house_usdt,
        (o.house_profit_orders_usdt + w.withdraw_fee_house_usdt) as house_profit_total_usdt,
        (0.05 * greatest(o.house_profit_orders_usdt + w.withdraw_fee_house_usdt, 0)) as affiliate_commission_due_usdt
      from orders o, withdraws w
    `;

    // Bind params: $1=start, $2=end, $3=affiliateId (quando houver)
    const rows: any[] = isGlobal
      ? await prisma.$queryRawUnsafe(sql, startISO, endISO)
      : await prisma.$queryRawUnsafe(sql, startISO, endISO, aff.id);

    const r = rows?.[0] || {};

    // Mapeia para o JSON v2 esperado pelo front/OPS
    res.json({
      version: "v2",
      range,
      timezone: tz,
      scope: isGlobal ? "global" : "affiliate",
      summary: {
        referrals: Number(r.referrals_total || 0),
        orders: Number(r.orders || 0),
        volume_usdt: Number(r.volume_usdt || 0),
        house_profit_usdt: Number(r.house_profit_total_usdt || 0),
        house_profit_orders_usdt: Number(r.house_profit_orders_usdt || 0),
        withdraw_amount_total_usdt: Number(r.withdraw_amount_total_usdt || 0),
        withdraw_fee_house_usdt: Number(r.withdraw_fee_house_usdt || 0),
        house_profit_total_usdt: Number(r.house_profit_total_usdt || 0),
        affiliate_commission_due_usdt: Number(r.affiliate_commission_due_usdt || 0),
        commissions_paid_usdt: 0, // (a implementar, se houver tabela de pagamentos)
      },
    });
  } catch (err) {
    console.error("[metrics] summary failed:", err);
    return res.status(500).json({ error: "AFFILIATE_METRICS_SUMMARY_FAILED" });
  }
});

export default affiliateMetricsRouter;
