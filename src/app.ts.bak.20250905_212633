import debugRouter from './routes/debug.routes';
import { microcache } from './middlewares/microcache';
import express, { Request, Response } from 'express';
import { requireAuth } from './middlewares/requireAuth';
import cors, { type CorsOptions } from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import cookieParser from 'cookie-parser';

import apiRouter from './routes';
import { errorHandler } from './middlewares/errorHandler';
import { rateLimiter } from './middlewares/rateLimiter';
import { referralCookie } from './middlewares/referralCookie';
import { normalizeAuthHeader } from './middlewares/normalizeAuthHeader';

const app = express();

/** Segurança extra: não expor header X-Powered-By */
app.disable('x-powered-by');

/**
 * Confiar no proxy para usar X-Forwarded-For corretamente.
 * - Padrão seguro: 1 (Nginx único à frente).
 * - Se usar Cloudflare + Nginx, pode usar TRUST_PROXY=2.
 * - Evite "true" para não aceitar XFF spoofado do cliente.
 */
const TRUST_PROXY = process.env.TRUST_PROXY ?? '1';
app.set('trust proxy', TRUST_PROXY === 'true' ? true : Number(TRUST_PROXY));

/** Helmet (segurança básica) — HSTS desabilitado aqui (já controlado no Nginx) */
app.use(
  helmet({
    hsts: false,
    frameguard: false, // evita Strict-Transport-Security duplicado
    crossOriginResourcePolicy: { policy: 'same-site' },
  })
);

/** CORS (aceita Authorization + cookies) */
const ENV_ALLOWED =
  process.env.ALLOWED_ORIGINS?.split(',').map(s => s.trim()).filter(Boolean) ?? [];
const ALLOWED_ORIGINS = Array.from(
  new Set([
    ...ENV_ALLOWED,
    process.env.FRONTEND_URL || 'https://www.betforbes.com',
    'https://betforbes.com',
    'http://localhost:5173',
    'http://localhost:3000',
  ])
);

const corsOptions: CorsOptions = {
  origin: (origin, cb) => {
    if (!origin) return cb(null, true); // curl/postman
    if (ALLOWED_ORIGINS.includes(origin)) return cb(null, true);
    // não lançar erro para evitar 500; apenas desabilita CORS para essa origem
    return cb(null, false);
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
  exposedHeaders: ['ETag', 'RateLimit-Limit', 'RateLimit-Remaining', 'RateLimit-Reset'],
  optionsSuccessStatus: 204,
};
app.use(cors(corsOptions));
app.options('*', cors(corsOptions));

/** Body parsers */
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

/** Cookies (necessário para o referral cookie HttpOnly) */
app.use(cookieParser());

/**
 * Rota curta de referral:
 * - Atende GET **e** HEAD (curl -I)
 * - Seta cookie HttpOnly "bf_ref" com o código
 * - Redireciona para /cadastro?ref=<CODE> no frontend
 *
 * IMPORTANTE: esta rota deve vir ANTES do mount do /api e do 404 handler.
 */
app.all('/r/:code', (req: Request, res: Response) => {
  // Aceita apenas GET e HEAD; demais => 405
  if (req.method !== 'GET' && req.method !== 'HEAD') {
    return res.sendStatus(405);
  }

  const raw = String(req.params.code || '').trim();
  const code = raw.toUpperCase();

  res.cookie('bf_ref', code, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production', // HTTPS em prod; permite teste local em HTTP
    sameSite: 'lax',
    maxAge: 1000 * 60 * 60 * 24 * 30, // 30 dias
    path: '/', // todo o site
    domain: process.env.COOKIE_DOMAIN || undefined, // ex.: .betforbes.com em produção
  });

  const frontend = (process.env.FRONTEND_URL || 'https://www.betforbes.com').replace(/\/+$/, '');
  return res.redirect(302, `${frontend}/cadastro?ref=${encodeURIComponent(code)}`);
});

/** Captura ?ref= e salva cookie HttpOnly também (via middleware) */
app.use(referralCookie);

/** Logs */
app.use(morgan('tiny'));

// --- DEBUG ENDPOINTS (EARLY, sem auth; antes do rateLimiter/apiRouter) ----
app.get('/api/_debug/echo-auth', (req: Request, res: Response) => {
  const h = req.headers.authorization;
  const masked = typeof h === 'string'
    ? h.replace(/(Bearer\s+)(.{8}).+/, '$1$2…')
    : h;
  res.json({ auth: masked, ip: req.ip, xff: req.headers['x-forwarded-for'] });
});
app.get(
  '/api/_debug/mc',
  microcache({ ttlMs: 3000, key: (req: Request) => `mc:${req.ip}` }),
  (_req: Request, res: Response) => res.json({ ok: true, now: Date.now() })
);
// --------------------------------------------------------------------------
app.use((req, res, next) => { const rid = req.get('x-request-id') || (Date.now().toString(36) + Math.random().toString(36).slice(2,8)); res.set('Request-Id', rid); if (!res.get('X-Frame-Options')) res.set('X-Frame-Options', 'DENY'); next(); });
app.use((req, res, next) => { const rid = req.get('x-request-id'); if (rid && !res.get('Request-Id')) res.set('Request-Id', rid); if (!res.get('X-Frame-Options')) res.set('X-Frame-Options', 'DENY'); next(); });
/** Healthchecks (isentos de rate limit) */
app.get('/healthz', (_req: Request, res: Response) => res.json({ ok: true }));
app.get('/api/healthz', (_req: Request, res: Response) => res.json({ ok: true }));

/** Normaliza Authorization: Bearer <token> em TODA a API (antes do rate limit) */
app.use('/api', normalizeAuthHeader);

/** Rate limit global (usa req.ip já corrigido pelo trust proxy) */
app.use(rateLimiter);

/**
 * Guarda simples para /api/auth/profile:
 * - Responde 200 se houver um header Authorization com Bearer <token>
 * - Responde 401 se não houver
 * (Não faz validação do JWT; isso fica para o middleware de auth real quando você quiser.)
 */
app.get('/api/auth/profile', (req: Request, res: Response): void => {
  const auth = String(req.headers.authorization || '');
  const hasBearer = /^Bearer\s+\S+/i.test(auth);
  if (!hasBearer) {
    res.status(401).json({ success: false, code: 'UNAUTHORIZED', message: 'Missing Bearer token' });
    return;
  }
  res.status(200).json({ success: true, message: 'OK (guard simples)', data: null });
});

/** (Opcional) endpoint de debug para inspecionar o Authorization recebido */
if (process.env.DEBUG_ECHO_AUTH === '1') {
  app.get('/api/_debug/echo-auth', (req: Request, res: Response) => {
    const h = req.headers.authorization;
    const masked = typeof h === 'string' ? h.replace(/(Bearer\s+)(.{8}).+/, '$1$2…') : h;
    res.json({
      auth: masked,
      ip: req.ip,
      xff: req.headers['x-forwarded-for'],
    });
  });
}

/** Todas as rotas da API ficam sob /api */
app.use('/api', apiRouter);

/** 404 para rotas não encontradas (antes do errorHandler) */
app.use((req: Request, res: Response) => {
  res.status(404).json({ success: false, message: 'Rota não encontrada' });
});

/** Handler de erros (sempre por último) */
app.use(errorHandler);

// Debug: microcache 3s por IP
app.get('/api/_debug/mc',
  microcache({ ttlMs: 3000, key: (req: Request) => `mc:${req.ip}` }),
  (_req: Request, res: Response) => res.json({ ok: true, now: Date.now() })
);
app.use('/api/_debug', debugRouter);
export default app;
